#!/usr/bin/env ruby

require_relative '../lib/piwigo_client'

require 'optparse'
require 'progress_bar'

# ----------------------------------------------------------------------

class UploaderError < RuntimeError; end

def full_category_name(categories, id)
  parent_ids = categories[id]['uppercats'].split(',').map(&:to_i)
  parent_ids.map { |parent_id| categories[parent_id]['name'] }.join('::')
end

def convert_category(client, cat_name)
  categories = client.get_categories(false).map { |c| [c['id'], c] }.to_h
  matches = categories.keys.select { |id| categories[id]['name'].casecmp(cat_name).zero? }

  unless matches.any?
    $stderr.puts "No matches found for category '#{cat_name}'"
    raise UploaderError
  end

  if matches.count == 1
    category_id = matches.first
    full_name = full_category_name(categories, category_id)
    $stderr.puts "Uploading to category #{category_id} #{full_name}"
    return category_id
  end

  $stderr.puts "Multiple matches found for category '#{cat_name}':"
  matches.each do |id|
    full_name = full_category_name(categories, match)
    $stderr.puts "  (#{id}) #{full_name}"
  end
  raise UploaderError
end

def match_category(client, category)
  if category.match(/\A\d+\z/)
    category.to_i
  else
    convert_category(client, category)
  end
end

def handle_file_files(raw_list)
  [].tap do |file_list|
    raw_list.each do |filename|
      if filename.start_with?('@')
        file_file = filename[1..]
        unless File.exist?(file_file)
          $stderr.puts "Error: @file #{file_file} not found"
          raise UploaderError
        end
        file_list += File.readlines(file_file).map(&:chomp)
      else
        file_list << filename
      end
    end
  end
end

def handle_directories(raw_list, recurse = false)
  [].tap do |file_list|
    until raw_list.empty?
      work_list = raw_list
      raw_list = []
      work_list.each do |filename|
        if File.directory?(filename)
          if recurse
            raw_list += Dir.glob("#{filename}/*")
          else
            warn "Skipping directory #{filename}"
          end
        else
          file_list << filename
        end
      end
    end
  end
end

def get_file_sizes(file_list)
  errors = []
  file_sizes = file_list.map do |filename|
    begin
      [filename, File.stat(filename).size]
    rescue Errno::ENOENT
      errors << filename
    end
  end.to_h

  if errors.any?
    errors.each { |filename| $stderr.puts "Error: couldn't find file #{filename}" }
    raise UploaderError
  end

  file_sizes
end

def get_file_data(recurse = false)
  file_list = handle_file_files(ARGV)
  file_list = handle_directories(file_list, recurse)
  file_data = get_file_sizes(file_list)

  unless file_data.any?
    $stderr.puts "Error: You must specify one or more files to upload."
    raise UploaderError
  end

  file_data
end

# ----------------------------------------------------------------------

options = {
  'config' => '.piwigo.conf',
  'files' => [],
  'recurse' => false
}

parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] -c category (file | @list)..."

  opts.separator ''
  docstring = 'Set location of JSON configuration file (default: .piwigo.conf).'
  opts.on('--config FILE', docstring) { |o| options['config'] = o }
  opts.on('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end

  opts.separator ''
  opts.separator 'Connection options (required):'
  opts.on('-b', '--base_uri HOSTNAME', 'Hostname of Piwigo server') { |o| options['base_uri'] = o }
  opts.on('-u', '--username USERNAME', 'Username') { |u| options['username'] = u }
  opts.on('-p', '--password PASSWORD', 'Password') { |p| options['password'] = p }

  opts.separator ''
  opts.separator 'Image options:'
  docstring = 'Piwigo category to upload files into (required)'
  opts.on('-c', '--category ID', docstring) { |o| options['category'] = o }
  docstring = 'Recurse into directories (default: off)'
  opts.on('-r', '--recurse', TrueClass, docstring) { |o| options['recurse'] = o }

  opts.separator ''
  opts.separator 'Specifying files:'
  opts.separator '  List one or more files on the command line after the arguments.'
  opts.separator '  If a filename starts with @, it will be treated as a newline-separated list of files.'
  opts.separator '  Directories will be skipped unless -r is turned on.'
end

parser.parse!

if File.exist?(options['config'])
  begin
    options = JSON.parse(File.read(options['config'])).merge(options)
  rescue JSON::ParserError
    puts "Error reading #{options['config']}; is it a JSON file?"
  end
elsif options['config'] != '.piwigo.conf'
  warn "Config file #{options['config']} not found; proceeding without it"
end

%w[base_uri username password category].each do |key|
  unless options[key]
    $stderr.puts "Error: You must set a value for #{key}"
    puts parser
    exit
  end
end

file_data = get_file_data(options['recurse'])
total_data = file_data.values.sum

puts "Connecting to Piwigo at #{options['base_uri']} with username #{options['username']}"
client = PiwigoClient.new(base_uri: options['base_uri'], username: options['username'],
  password: options['password'])
client.login
begin
  client.check_session_status

  category_id = match_category(client, options['category'])

  pbar = ProgressBar.new(total_data, :bar, :percentage, :eta)
  file_data.each do |filename, _|
    pbar.puts "Uploading #{filename}"
    client.upload_file(filename, category_id, pbar)
  end
ensure
  client.logout
end
